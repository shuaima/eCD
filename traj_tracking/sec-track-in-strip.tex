
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "www2019"
%%% End:

\section{Tracking in a strip area}
\label{sec:strip}




%\subsection{Position tracking in strip areas}
%based on ldr, a direction is needed, no speed;
%  --  distance checking during computing, ped: from a point to a ray.
  

\subsection{\ped, sector and trajectory simplification}
\label{sec:sector-in-simp}



\subsection{Tracking by sectors}



\subsection{Implementation}

We then present a one-pass trajectory tracking algorithm based on full-$\epsilon$ sector, named \underline{S}ector \underline{I}ntersection for \underline{T}rajectory \underline{T}racking (\sitt). As shown in Figure ~\ref{alg:sitt}, \sitt runs in a similar routine as \citt excepts that (1) \sed and spatio-temporal cone are replaces by \ped and sector, (2) only the direction information of $\vv{v}$ is needed while the speed information is not, such that when a distance deviation occurs, \sitt quickly finds out a new feasible direction of velocity $\vv{v}$ by the intersection of sectors and sends it to the MOD server, and (3) it temporarily saves the maximum length of $|P_sP_{s+j}|$, $j\in (0, i)$, in $l_m$ and compares it with the length $|P_sP_{s+i}|$ of the current point $P_{s+i}$ during the process, as mentioned in Theorem \ref{theo-full-sector}. 
%
During tracking, the moving object is in a strip around the velocity. And after simplification, those removed points are located in $2\epsilon$--width strips around those saved points.





\stitle{Correctness and complexity.} 
The correctness of algorithm \sitt follows from Theorems \ref{theo-half-sector} and \ref{theo-full-sector}.
It is also easy to find that every point is processed only once in \sitt, and for each point, it needs $O(1)$ time as getSector() \cite{Zhao:Sleeve}, intersecting of sectors \cite{Zhao:Sleeve} and {other operations} all have a time complexity of $O(1)$. Hence, \sitt has a time complexity of $O(n)$, where $n$ is the number of data points.



